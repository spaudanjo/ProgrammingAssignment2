## These two functions allow you create a special 'wrapper object' arounds a normal matrix which can hold 
## the cached result of the (potentially) cost intense matrix inversion. 
## You can simply create a matrix with the makeCacheMatrix function and then pass this to the function cacheSolve. 
## cacheSolve will compute the inverted matrix or, if done before for the exact same matrix, will use the cached result. 
## Info: The matrix needs to be invertible, e.g. it needs to be a square matrix. 

## For testing, call e.g. the following function like this:
## testCachedInvertedMatrix(n = 1500)
testCachedInvertedMatrix = function(n = 1000)
{
  mat = matrix(sample(1:(n*n)), n)
  cachedMat = makeCacheMatrix(mat)
  
  message("Original matrix:")
  str(cachedMat$get())
  
  message("First run...")
  str(cacheSolve(cachedMat))
  ## the second time the "computation" should take much less time, since it is a cached hit
  message("Second run...")
  str(cacheSolve(cachedMat))
  
  
  message("Resetting the underlying matrix")
  cachedMat$set(matrix(sample(1:1000000), 1000))
  message("(New) original matrix:")
  str(cachedMat$get())

  ##after resetting the matrix, the next computation will take longer again, since the cache value was reset
  message("Run inversion computation once more witht the new underlying matrix")
  str(cacheSolve(cachedMat))
}

# makeCacheMatrix takes a matrix and returns as list consisting of 4 functions: 
# * $get: returns the underlying matrix
# * $set: overrides the underlying matrix and resets the internal cache field for the inverted matrix
# * $getInv: returns the cached field for the inverted matrix; might return null, e.g. when the function $setInv hasn't been called yet
# * $setInv: sets/overrides the internal cache field for the inverted matrix
makeCacheMatrix <- function(x = matrix()) {
  inv <- NULL
  get = function() x
  set = function(m) {
    inv <<- NULL
    x <<- m
  }
  setInv = function(i) inv <<- i
  getInv = function() inv
  
  list(set = set, get = get, setInv = setInv, getInv = getInv)
}


## This function expects a wrapped/special matrix object, generated by the function makeCacheMatrix. 
## It will then 
## a) compute the inverted matrix and sets the cached field
## or
## b) if the matrix object has already an value different than NULL for the inverted matrix, 
## returns this cached value. 
cacheSolve <- function(x, ...) {
  inv = x$getInv()
  if(!is.null(inv))
  {
    message("cache hit!")
    return(inv)
  }
  x$setInv(solve(x$get(), ...))
  x$getInv()
}
